{"pages":[{"url":"http://newDreamA.github.io/thread/多线程之线程创建.html","text":"线程的创建方式 继承Thread类 实现Runnable接口 实现Callable接口 继承Thread的实现方式: public class ThreadA extends Thread｛ public void run(){ super.run(); } ｝ 实现Runnable接口的实现方式: public class ThreadB implements Runnable{ public void run(){ super.run(); } } 实现Callable接口的call方法的实现方式： import java.util.concurrent.Callable; public class ThreadC implements Callable { public String call()throws Exception{ System.out.println(\"ThreadC\"); return \"ThreadC\"; } } 以上三种方式的在main函数中应用 public static void mian(String[] args){ //线程A的启动方式 ThreadA threadA = new ThreadA(); threadA.start(); //线程B的启动方式 ThreadB threadB = new ThreadB(); new Thread(threadB).start(); //线程C的启动方式 ThreadC threadC = new ThreadC(); FutureTask task = new FutureTask (threadC); new Thread(threadC).start(); //获取线程的返回结果 task.get(); } 在没看有关线程的书籍之前我只知道有两种创建线程的方式，看了相关书籍才了解了还有第三种创建的方法，所以不能只局限于原来的知识。","tags":"Thread","title":"创建线程的方式"},{"url":"http://newDreamA.github.io/she-ji-mo-shi-ji-lei/单例模式.html","text":"单例模式 单例：简而言之就是一个环境中只有一个实例 java中单例模式的注意点有： 将他的构造函数私有化 将对像声明为static 不对外提供get和set方法 java中的简单的3种 1.该获取单例的方法的缺点是不能控制何时生成实例 1 2 3 4 5 6 7 public class SingltonDemo{ private static SingltonDemo instance; private SingltonDemo(){} public static SingltonDemo getInstance(){ return instance; } } 2.该获取单例的方法有同步操作，性能用影响 1 2 3 4 5 6 7 8 public class SingltonDemo｛ private static SingltonDemo instance=null; private SingltonDemo(){} pulic static SingltonDemo synchronized getInstance(){ if(instance==null){ instance=new SingltonDemo(); } ｝ 3.一个比较好的方法 1 2 3 4 5 6 7 8 9 10 public class SingltonDemo{ private SingltonDemo(){} private static class SingltonHelper{ private static SingltonDemo instance=new SingltonDemo(); } public static SingltonDemo getInstance(){ return SingltonHelper.instance; } }","tags":"设计模式积累","title":"单例模式"},{"url":"http://newDreamA.github.io/springboot/springBoot修改内置容器端口号.html","text":"SpringBoot修改内置容器的方法 第一个最简单的方法就是在application.yml配置，配置方法如下： 1 2 3 # Server settings server: port: 8080 实现EmbeddedServletContainerCustomizer的customize的方法 1 container.setPort(8000)","tags":"springBoot","title":"springBoot修改内置容器的端口号"},{"url":"http://newDreamA.github.io/springboot/springBoot入门.html","text":"gradle搭建SpringBoot开发环境 首先现在gradle 版本为2.2.1文件下载地址:http://gradle.org/gradle-download/ 在intelliJ IDEA 14.0.2创建gradle项目 (1) File->New Product->Gradle如图所示： （2）给工程命名为example: (3) 创建完成后工程的目录结构为： (4)在build.gradle中配置如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 apply plugin: 'java' sourceCompatibility = 1.8 version = '1.0' buildscript { repositories { jcenter() mavenCentral() } dependencies { classpath(\"org.springframework.boot:spring-boot-gradle-plugin:1.2.3.RELEASE\") } } apply plugin: 'java' apply plugin: 'spring-boot' jar { baseName = 'myproject' version = '0.0.1-SNAPSHOT' } repositories { jcenter() mavenCentral() } dependencies { compile(\"org.springframework.boot:spring-boot-starter-web\") testCompile(\"org.springframework.boot:spring-boot-starter-test\") } (5)build项目: 显示出gradle的界面，然后点击 然后程序会下载相应的jar包 (6)创建个测试类 测试类中的源码如下： import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * Created by txw on 2015/12/29. */ @ RestController @ EnableAutoConfiguration public class Example { @ RequestMapping ( \"/\" ) String home () { return \"Hello World!\" ; } public static void main ( String [] args ) throws Exception { SpringApplication . run ( Example . class , args ) ; } } 然后运行，最后在浏览器中输入localhost:8080,出现如下结果表示成功！","tags":"springBoot","title":"springBoot入门"},{"url":"http://newDreamA.github.io/java/java常见方法总结.html","text":"java常见方法总结 1.指定随机数的生成范围 1 2 3 4 public int getRandomRangeNum(int start,int end){ int result=start+(int)(Math.random()*(end-start)); return result; }","tags":"java","title":"java常见方法总结"},{"url":"http://newDreamA.github.io/mysql/MySQL常用语句.html","text":"Mysql常见一些操作语句 1. 创建数据库的： CREATE DATABASE IF NOT EXISTS auth DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 2. 自增类型定义: auto_increment 3. 时间日期的格式化： DATE_FORMAT(time,'%y-%m-%d %T') mySql的日期格式化示例： DATE_FORMAT(date, format) select date_format(now(),'%y-%m-%d'); format参数说明： %S, %s 两位数字形式的秒（ 00,01, …, 59） %I, %i 两位数字形式的分（ 00,01, …, 59） %H 两位数字形式的小时，24 小时（00,01, …, 23） %h 两位数字形式的小时，12 小时（01,02, …, 12） %k 数字形式的小时，24 小时（0,1, …, 23） %l 数字形式的小时，12 小时（1, 2, …, 12） %T 24 小时的时间形式（hh:mm:ss） %r 12 小时的时间形式（hh:mm:ss AM 或hh:mm:ss PM ） %p AM 或 PM %W 一周中每一天的名称（Sunday, Monday, …, Saturday） %a 一周中每一天名称的缩写（Sun, Mon, …, Sat） %d 两位数字表示月中的天数（00, 01,…, 31） %e 数字形式表示月中的天数（1, 2， …, 31） %D 英文后缀表示月中的天数（1st, 2nd, 3rd,…） %w 以数字形式表示周中的天数（ 0 = Sunday, 1=Monday, …, 6=Saturday） %j 以三位数字表示年中的天数（ 001, 002, …, 366） %U 周（0, 1, 52），其中Sunday 为周中的第一天 %u 周（0, 1, 52），其中Monday 为周中的第一天 %M 月名（January, February, …, December） %b 缩写的月名（ January, February,…., December） %m 两位数字表示的月份（01, 02, …, 12） %c 数字表示的月份（1, 2, …., 12） %Y 四位数字表示的年份 %y 两位数字表示的年份 %% 直接值\"%\" 4.插入数据检查数据是否存在： 当记录不存在的时插入，当记录存在时更新 在insert中使用 ON DUPLICATE KEY UPDATE 5. 解决datetime类型的比较问题， 使用STR_TO_DATE函数，例如 add_time >=STR_TO_DATE(‘2016-06-28 13:22:12','%Y-%m-%d %H:%i:%s') 6. 删除原先主键，重新生成主键 ALTER TABLE table_name ADD COLUMN id INT (11) NOT NULL AUTO_INCREMENT AFTER name_field, DROP PRIMARY KEY , ADD PRIMARY KEY (id);","tags":"mysql","title":"Mysql常见一些操作语句"},{"url":"http://newDreamA.github.io/java/java常见错误总结.html","text":"java错误归纳 使用BigDecimal的divide时候要设置精确的小数点，不然在除不尽的时候会抛出java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result. Integer能使用等于号的范围是-128~127","tags":"java","title":"java错误归纳"},{"url":"http://newDreamA.github.io/react/scss环境搭建.html","text":"SCSS 的环境配置 外部依赖说明 node的版本：node-v0.12.8-x64 ruby的版本:rubyinstaller_V2.2.2.95_setup node安装所需要的js文件 以下这些最好安装到项目的目录文件夹下 node install gulp -g node install gulp-util node install gulp-ruby-sass node install gulp-autoprefixer gem install sass 这是ruby的命令 本地的配置文件 与scss同级目录下，先建立一个gulpfile.js文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 use strict; var gulp = require('gulp'); var sass = require('gulp-ruby-sass'); var autoprefixer = require('gulp-autoprefixer'); gulp.task('default', function () { return sass('scss/*.scss', { style: 'compressed', noCache: true }) .on('error', function (err) { console.error('Error!', err.message); }) .pipe(autoprefixer()) .pipe(gulp.dest('css/')); }); gulp.task('watch', function () { gulp.watch('scss/*.scss', ['default']); }); 然后命令行当前目录切换到存放gulp.js的目录下后，执行gulp。","tags":"react","title":"SCSS 的环境配置"},{"url":"http://newDreamA.github.io/springboot/springBoot与MyBatis整合示例.html","text":"springBoot与MyBatis整合示例 MyBatis的配置的一般步骤： 数据源的配置 配置MyBatis的映射xml 配置mybatis的sqlSessionFactory Mybatis的相关jar 以下是gradle的引jar的包的方式： 1 2 3 4 5 6 7 complie \"org.springframework.boot: spring-boot-starter-jdbc:1.2.3.RELEASE\" compile \"org.mybatis:mybatis:3.2.8\" compile \"org.mybatis:mybatis-spring:1.2.1\" compile \"com.alibaba:druid:1.0.13\" compile \"mysql:mysql-connector-java:5.1.35\" compile \"com.alibaba:fastjson:1.1.41\" 使用springBoot的最大好处是可以使用javaConfig来配置属性，其实它类似与spring中的xml配置，在springBoot中可以使用yml文件来配置一些属性，下面就是用yml来配置数据源和mybatis的xml映射关系的：application.yml,配置如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 druid : dataSource : driverClassName : com . mysql . jdbc . Driver url : jdbc : mysql :// localhost : 3306 / test username : root password : initialSize : 5 maxActive : 200 minIdle : 5 maxWait : 60000 validationQuery : SELECT 1 FROM DUAL removeAbandoned : true removeAbandonedTimeout : 180 mapperLocations : classpath *: com . mapper .*/ * Mapper . xml 以下是javaConfig的配置 1.首先创建个DataSourceSettings来加载数据库的来源： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import com.alibaba.druid.pool.DruidDataSource ; import org.springframework.boot.context.properties. ConfigurationProperties ; /** * Created by tangxiewen on 2016 / 5 / 31. */ @ConfigurationProperties ( prefix = DataSourceSettings . PREFIX ) public class DataSourceSettings extends DruidDataSource { public static final String PREFIX = \"druid.dataSource\" ; private String mapperLocations ; public String getMapperLocations () { return mapperLocations ; } public void setMapperLocations ( String mapperLocations ) { this . mapperLocations = mapperLocations ; } } 2.在创建个DataSourceAutoConfiguration用于注册SqlSessionFactoryBean，源码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import org.mybatis.spring.SqlSessionFactoryBean ; import org.mybatis.spring.annotation.MapperScan ; import org.slf4j.Logger ; import org.slf4j.LoggerFactory ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.context.properties.EnableConfigurationProperties ; import org.springframework.context.ApplicationContext ; import org.springframework.context.annotation.Bean ; import org.springframework.context.annotation.Configuration ; import java.io.IOException ; /** * Created by tangxiewen on 2016 / 5 / 31. */ @Configuration @MapperScan ( basePackages = { \"com.mapper\" }) @EnableConfigurationProperties ( DataSourceSettings . class ) public class DataSourceAutoConfiguration { private static final Logger logger = LoggerFactory . getLogger ( DataSourceAutoConfiguration . class ); @Autowired DataSourceSettings settings ; @Bean public SqlSessionFactoryBean sqlSessionFactory ( ApplicationContext applicationContext ) throws IOException { SqlSessionFactoryBean sqlSessionFactory = new SqlSessionFactoryBean (); sqlSessionFactory . setDataSource ( settings ); sqlSessionFactory . setMapperLocations ( applicationContext . getResources ( settings . getMapperLocations ())); return sqlSessionFactory ; } } 最后要在src/main/resources/创建一个 META - INF 文件夹在里面放置一个spring.factories文件，主要用于告知springBoot用我们的配置代替默认的配置 org.springframework.boot.autoconfigure.EnableAutoConfigur ation=\\com.jdbc.DataSourceAutoConfiguration 等于后面是类的全类名的形式即包名＋类名 注意点 就是用使用myBatis时mapper中的java类和xml的包名要一致，还是就是用idea注意一下他的包结构，不然会报绑定错误！！！","tags":"springBoot","title":"springBoot与MyBatis整合示例"}]}